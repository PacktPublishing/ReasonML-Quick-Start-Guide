It is a best practice to focus on designing data rather than code. By the terms designing data we mean the data structures. ReasonML is a language that orbits around data.

Consider an example of the JSON data in object oriented typed system like javascript. A JSON is received from the server response. At client side we use this data in the overall application, passing it from various function to other function . And at some point we need to trace the keys inside that data whether it is not undefined so that we can use it for rendering a component. We can compel with this situation until the application grows substantially with respect to it functionality and the tracing becomes difficult. Different aspects of reasonml such as syntax, type system, immutability, and functional nature etc help us to adhere such issue at compile time itself. To know about handling JSON data in reason, we are going to start with

Records in reason
Convert Record to Javascript-Object-Notation
bs-JSON library at rescue
Learning advanced concepts of handling JSON using graphQL
Before starting with Records in reason, in this chapter we are going to refer the sample app that we created in chapter 2, ‘Setting Up a Development Environment’. Here is github link for reference : <Give the link of one single page>

Records in reason
Because in object-oriented type systems like javascript, types are intertwined with the notion of a class. To explain this statement, consider the type string, number, boolean etc which are linked with notion of class or instances in javascript. This means when we declare a string as shown in the  following:

let greeting = “Hello”;
We get a property of the length

greeting.length // Output : 5

Normally as a beginner we have no idea from where this property arrived, but this property is provided by type string instance when we assigned. Basically javascript treats primitive values as objects.

Learn more on properties here : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Properties)
Incase of reasonML, the types acts specifically with respect to shape and data structure. So here, we can first declare the type

type employee = {name : string, code: int}
And then assign value with respect to type

let employeeRecord: employee = {name: "hulk", code: 112};
The above semantic looks similar to javascript object but is not same as object. It is called as a record. The use of parentheses represents a scope. A scope can have different data type of keys  

Going through some record rules :

The records needs explicit declaration as shown above before its usage
The key names in our case name and code should always start with lowercase
In reason, the field names or key names are used to determine the type of record so no repeatedly declaration in same scope is allowed.
In case if we use same field name in the two different objects ops! records, The usability suffers in case using the field name only the last record field value is received and complexity increases in retrieval of previous one. Hence, always recommended to have new one
By default records are immutable
Lets not worry about remembering each and every rule, our compiler helps us when we don’t follow one. Moving ahead to access the data as shown as followsJs.log(employeeRecord.name);
Dot(.) operator is used to access the data.
To make a comparative study, javascript objects are can either be used as records or hashmaps to store the references. Incase of reasonml, if we want to use as record follow the record creation way as shown above or learn to create hashmaps as shown in next section.

Object creation using Js.Dict
Consider a case when we don’t want to use a record with a fixed shape and data structure. What we mean by fixed shape is the use case requires dynamic keys to be generated in an record. Js.Dict can be used in such cases. Let us consider following example.

let employeeNewRecord = Js.Dict.empty()
The above line is equivalent of  javascript code : `let employeeNewRecord = {};

Js.Dict.set(employeeNewRecord, "name", ”hulk”);
Here is way of assigning value to the key in dictionary. We can go on adding in same way until the data type doesn’t change.

Js.Dict.set(employeeNewRecord, "code", 123); //error, Value must be of same type
Now the question arises, does the JS object creation using Js.dict module suppport variant data types?

The answer is no. But there is way through which we can get a javascript object or JSON with variant types using Js.dict. Let us understand it by unveiling the code step by step.

We are going to use variant instead and add to dictionary. In reason, we do this using type keyword as shown below
Type variantTypesToBeAdded =
| Code of int
| Designations of string array
[@@bs.deriving accessors]
We will learn about `@@bs..` keywords in upcoming steps but first in above code we have a structure of variants that contains:

The Code or Designations which are called as variant constructors and not variables or references.
The constructor need to be first letter capitalized
The bar separates the multiple constructors variants
Now use this variants constructor and pass the value as a parameter as shown below
Js.Dict.set(employeeNewRecord,"code",Code(212));
Js.Dict.set(employeeNewRecord,"designations",Designations([“ceo”, “cto”]));
 On runtime, the variables for eg. code(212) that are assigned in set method to key “code” with respect to javascript becomes as follows

employeeNewRecord["code"] = /* code */212;
You can see that the type variable are not directly stored/assigned in javascript object rather then are striped out and put in plain javascript object as comments and the value is assigned to the key. This also solutes that the variant types doesn’t have values at runtime. On running this javascript snippet we cannot get back the value of variant type code. To avoid this situation and bind the variant naturally to javascript object for eg :

employeeNewRecord["code"] = code;
we use annotation accessors.

And this is how we can create an object via Js.dict.

By now we have learned to convert the reason object structure (record or dictionary) to Javascript object notation. We are all ready to start with higher level JSON helper in next section.

Working with BS-JSON library
Parsing a simple JSON in typed safe language like reasonml is not that easy. The operation makes sure it handle the different data types properly and efficiently. BS-JSON library after the name bucklescript JSON provides us the functionality that handles the parses into JSON or converts it into record.

Let us move ahead by installing it using npm command

npm i @glennsl/bs-json --save
Add the package name @glennsl/bs-json to bs-dependencies array on bsconfig.json file as shown below.

"bs-dependencies": [
     "reason-react",
     "@glennsl/bs-json"
],
And we are ready to work on it!

When we read about BS-JSON library on its main website, they have called it compositional library. This is because unlike javascript, the whole coding mechanism goes with different steps :

Before starting lets have a take a note of the JSON structure we are planning to use

{
 "name": "bron",
 "code": 121,
 "designation": [
 "ceo",
 "cto"
 ],
 "address": {
 "street": "abc",
 "state": "MH",
 "country": "IND"
 }
}
Declare the data type of the JSON we need to decode. Consider the example of employee records.
let decodeEmployee = json =>
 Json.Decode.{
 name: json |> field("name", string),
 code: json |> field("code", int),
 designation: json |> field("designation", array(string)),
 address: json |> field("address", decodeAddress),
 };
In above snippet we have created a decoder function. In which we used JSON.Decode method to decode the JSON with different data type. We receive json (near the fat arrow) as a parameter to the function. We have used a composition operator(|>) to pickout a specific field from JSON and define its type. The procedure goes in a same way unless we are upto the addressfield. The address field is nothing but an object hence we can decompose its decoder and declare the data type as shown below



let decodeAddress = json =>
     Json.Decode. {
         street: json | > field("street", string),
         state: json | > field("state", string),
         country: json | > field("country", string),
     };
Note : make sure the sequence of decodeAddress variable declaration is before the snippet decodeEmployee.
The next step is interoping data as shown below
let data = {
 | {
     "name": "bron",
     "code": 121,
     "designation": ["ceo", "cto"],
         "address": {
             "street": "abc",
             "state": "MH",
             "country": "IND"
             }
         } |
     };
The reasonml official docs defines interoping as

Dumping in some JavaScript, and making it accessible from Reason

Reasonml.github.io
In the above snippet, we have made use of multiline delimiters (| something in between |) . The ‘Something in between’ here is nothing but a JSON, which we are going to convert to record using BS-JSON ‘s decode.

Note : When including javascript, the readers need to note that it a way of inject a javascript code directly without its type safe conversion.
At the end we are going to compose some functions in a pipeline as shown below.
let employeeDecode = data | > Json.parseOrRaise
     |
     > decodeEmployee
     |
     > Js.log;
In above snippet, the data passes through a sequence of composition functions. Json.parseOrRaise is responsible for parsing the interop JSON data provided in step 2. It can raise in case of any error exist. decodeEmployee is the decoder function and finally JS.log prints the resultant data to console.

And this is how we are going to implement decoder using BS-JSON. 

Working with reason and graphql

By now we have learned how to code in reasonml. Now let us move ahead with the most  common client server scenarios. In any web application scenario we make some multiple request to server and then receiving response from server. The more data is required the more number of API request are made. It is best to inverse the proportionality with respect to data and the number of api call in single way. What it means? Less api calls and some more specific data. Graphql works at this level.

Consider we created a server that serve the data of employees.

{
     name: "Hulk",
     code: "121",
     designation: ["cto", "ceo"],
         address: {
             country: "India",
             street: "xyz",
             state: "MH"
         }
 }
At some specific point o time this response JSON data values might go on increasing. Further, we may have a requirement of getting the `name` key and `code` key of employee. In this case, either we need to make a different API for get specific name and code or we need to use same API request. This results in creating a trade-off in cost of making more apis request performance or processing more data. Both seems expensive at some point of time.   

In this situation, graphql is at rescue. It lets us to query the simply ‘name’ and ‘code’ in same api api that was already build. Saves development time, performance cost.

Next, we are going to implement a simple example to integrate graphql with reasonml.

Here is github link to ber referred in case if we miss anything :

So let us go step by step

Installation process and environment
Let us install following list of node packages and some more development packages to build our server.

Take a look at package.json file shown below

{
 "name": "graphql-reason-example",
 "version": "0.1.0",
 "description": "A simple reasonml graphql app",
 "main": "server.js",
 "scripts": {
   "start": "npm-run-all --parallel start:*",
   "start:bsb": "bsb -clean-world -make-world -w",
   "webpack": "webpack -w",
   "start:server": "node src/apollo-server/server.js",
   "build": "npm-run-all build:*",
   "build:bsb": "bsb -clean-world -make-world"
 },
   "keywords": [],
   "author": "",
   "license": "MIT",
 "dependencies": {
   "apollo-server-express": "^1.1.2",
   "cors": "^2.8.4",
   "express": "^4.15.4",
   "react": "^15.4.2",
   "react-apollo": "^1.4.15",
   "react-dom": "^15.4.2",
   "reason-react": ">=0.2.1",
   "graphql-tag": "^2.4.2"
},
 "devDependencies": {
   "bs-platform": "^1.9.1",
   "npm-run-all": "^4.1.5",
   "webpack": "^1.14.0",
   "webpack-cli": "^3.1.1",
   "webpack-dev-server": "^3.1.14"
   }
}
Run the command

npm install

to install all the required packages.

Note : You may find some vulnerabilities notification as a warning in the terminal after the installation process. Those vulnerabilities are of low priority and exist only in packages that are in development dependencies. This development dependencies are not used in production level so we can neglect it.

2. Configuring bucklescript and webpack.config.js

Here is the code snippet  required in bsconfig.json

{
"name" : "graphql-reason-example",
"reason" : {"react-jsx" : 2},
"bsc-flags": ["-bs-super-errors"],
"bs-dependencies": ["reason-react"],
 "sources": [
   {
      "dir": "src",
      "subdirs": ["simple","simple/types"]
   }
 ]
}

The important keys to note : we have defined the main directory and sub directory as JSON value with sources key.  Other one is bs-dependencies key which contains the value as package name reason-react that is used while compiling process.

The webpack file code as shown below



const path = require('path');
module.exports = {
   entry: {
      simple: './lib/js/src/simple/Root.js',
   },
   output: {
      path: path.join(__dirname, "bundledOutputs"),
      filename: '[name].js',
   },
};

The notable keys are : `entry` which contains path of the main js file that contains the libraries required by webpack. The output key containing path key as directory link and filename respectively.

The source files
Our source directory consist of client code and server side code which are going to keep in respective directories.

We need to create a minimalist server that can handle our request and provide response to our graphql client. To do so we also need to implement the data formation and query part on server side using graphql supportive framework called as apollo.

In our server directory, we have server.js which is responsible for creating a simple API server with URI : http://localhost:4000/greeting

The server.js file snippet is as follows

const express = require('express');
const bodyParser = require('body-parser');
const {graphqlExpress} = require('apollo-server-express');
const {schema} = require('./schema');
const cors = require('cors');
const PORT = 4000;
const app = express();
app.use(cors());
app.use('/greeting', graphqlExpress({ schema: schema }));
app.listen(PORT, () => {
   console.log('Server is running on port ', PORT);
});;
The notable code lines in above snippet are:

We have used graphqlExpress function as a controller to handle the request. This module requires schema as a parameter. We will learn about schema module in later in this chapter.
We have used cors middleware to handle cross origin resources. We are using index.html file directly in browser. Using the index.html needs the file://path in URL of browser. The origin changes. On production level it can be http but still we can host it with respect to different origin. So we have handled the scenario ahead of time.
Listening the express app on specified port : 4000.


The graphql schema file
This file is the whole schema that is required to access the data according to queries. The structure contains of

Definitions : The definitions are used to to describe the whole data structure. Just like type declaration in reasonml, we define the structure using the type keyword. This can be seen as follow.

// Construct a schema, using GraphQL schema language

const typeDefs = `
   type Query {
   getGreeting: String
   }
`;
Resolvers : The resolvers are nothing but actions or methods that are responsible for querying the specific data. We can perform operations in the data here to response back in required format. Here is the resolver snippet

const resolvers = {
 Query: {
   getGreeting: () => (" World!")
  }
};
Finally we create a graphql instance using makeExecutableSchema as shown below :

exports.schema = makeExecutableSchema({
   typeDefs,
   resolvers,
});
For more information visit : https://graphql.github.io/learn/queries/

This was all about server side, let us move to client side.

Client side graphql coding
Let us start with index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Graphql reason example</title>
</head>
<body>
    <div id="index"></div>
    <script src="../../bundledOutputs/simple.js"></script>
</body>
</html>



We have linked the javascript source file. The directory contents of bundledOutputs are generated at compile time.

The reason code starts with as the name suggest ‘Root.re’

ReactDOMRe.renderToElementWithId <App/> "index";

In above snippet we have binded index as element id in index.html with the reason component. The component is named as App which is loaded from App.re, its code is as below

let component = ReasonReact.statelessComponent "App";
let make = fun _children => {
 ...component,
 render: fun _self => {
   <ApolloProvider client=ApolloClient.instance>
      <Greeting/>
   </ApolloProvider>
  }
};

The code above renders the User component which is wrapped inside of ApolloProvider component. The library instance is passed as client argument to the component.

The code of ApolloProvider component is as follow

type apolloProvider;

external apolloProvider: ReasonReact.reactClass = "ApolloProvider" [@@bs.module "react-apollo"];



let make ::client children => {
 ReasonReact.wrapJsForReason
   reactClass::apolloProvider
   props::{"client": client}
   children
};
In above code we have created a wrapper called apolloProvider. It is way to connect the apolloClient with the component. The component props are parameter of make function. The double colons :: before `client` means that it is a named parameter (that is assigned to props).

Moving ahead we have ApolloClient.re

type networkInterfaceResult;
type apolloClientResult;
type networkInterface = Js.t {. uri: string};
type apolloClient = Js.t {. networkInterface: networkInterfaceResult};
external createNetworkInterface: networkInterface => networkInterfaceResult = "createNetworkInterface" [@@bs.module "react-apollo"];
external apolloClient: apolloClient => apolloClientResult = "ApolloClient" [@@bs.new] [@@bs.module "react-apollo"];
   let networkInterface = createNetworkInterface {"uri": "http://localhost:4000/greeting"};
   let instance = apolloClient { "networkInterface": networkInterface };

In the above code we  used networkInterface and apolloClient instances by loading the bucklescript module respectively  and configured the uri to it.

Graphql at client-side
Now when we have our networkInterface ready we are ready to make an asynchronous request to the server from client. We also need to request the server for particular data by providing query based parameter in request.

Let go through the code as shown follow to understand the process.

open GraphQLTypes;
 external gql:gql = "graphql-tag" [@@bs.module];
 external graphql:graphql = "graphql" [@@bs.module "react-apollo"];
 type state = {prefix: string};
 type action =
 Click;
  let component = ReasonReact.reducerComponent "Greeting";
  let greet ::data _children => {
   ...component,
  initialState: fun () => { prefix: "Hello"},
  reducer: fun action state =>
      switch action {
      | Click => ReasonReact.Update {prefix: state.prefix == "Hello" ? "Hi" : "Hello"}
   },
      render: fun {state, reduce} => {
      let name = if(data##loading) {
    ""
      } else{
       data##getGreeting
   };
      <div
         onClick=(reduce (fun _event => Click)) 
      >
         (ReasonReact.stringToElement (state.prefix ^ " "))
         (ReasonReact.stringToElement (name))
      </div>
   }
};

/* Reason -> JS*/
let userJs = ReasonReact.wrapReasonForJs ::component (fun jsProps => {
 greet data::jsProps##data [||];
});
 let query =
  gql {|
    query getGreeting {
    getGreeting
   }
|} [@bs];
let graphqlQuery = graphql query [@bs];
let userWithQuery: ReasonReact.reactClass = graphqlQuery userJs [@bs];

/* JS -> Reason */
let make children =>
 ReasonReact.wrapJsForReason
   reactClass::userWithQuery
   props::(Js.Obj.empty ())
   children;
Here are some notable points,

Plugin graphql module is required using bucklescript annotation loader. It is responsible for easy manipulation of graphql strings to write queries in the code.
We created typestate to maintain the data’s current state of application. The state initial value is “Hello” which changes to “Hi” on click of the greeting text. The logic is written in greet function.
We can add number of action to switch currently we have defined only one in the type action.
The code :
/* Reason -> JS*/
let userJs = ReasonReact.wrapReasonForJs ::component (fun jsProps => {
   greet data::jsProps##data [||];
});
Is responsible to export your component to JS. It works by passing the reason data props to JS data props.

From Greet.re code snippet, next step is to create graphql query. And then use query to make an api query using the following code
let make children =>
 ReasonReact.wrapJsForReason
   reactClass::userWithQuery
   props::(Js.Obj.empty ())
   children;


It passes the userWithQuery as  parameter with empty props. The completes our Greeting.re file. Now our source code is ready. To start the project we need to run the following command in the terminal.

npm start

And then

npm run webpack

To separately run the webpack.

The output :





Summary
Summarizing our learning. In this chapter we started with the type records and how they can be used. The purpose to start with a record is to understand use of an object notations in reason. Moving ahead we learned about Js.Dict which works like javascript hashmaps. In javascript the objects are commonly used for both purposes but reason differentiate object on bases of records and hashmaps. Further we moved towards learning bs-JSON library which was one of the main goal of this chapter followed by graphql integration with reasonml. Reasonml has strange syntactical things but the language is powerful and provides overall positivity with respect to development.

